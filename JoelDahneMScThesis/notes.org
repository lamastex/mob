#+TITLE: SwapMob: Swapping trajectories for mobility Data anonymization
#+AUTHOR: Joel Dahne
* Define trajectories and co-trajectories
We begin by defining what we mean with trajectories and
co-trajectories.

Informally, a trajectory is a number of measurements of location
together with the times for the measurements. An example would be
position data from a GPS taken at certain times. Let \(L\) be the
location space consisting of all possible measurements of location,
this could for example be the set of GPS coordinates or the set of
coordinates on a city map. A measurement is given by a location
together with a timestamp, i.e. a measurement \(m\) can be represented
by an element in the set \(L \times \mathbb{R}\). We can now define a
trajectory as a set of measurements, a trajectory, \(r\), is then
given by a subset of \(L \times \mathbb{R}\). Let us denote the set of
trajectories by \(T\).

*Remarks:* Here we have a couple of options. We could choose to allow
at most one measurement per timestamp, i.e. for a trajectory, \(r\),
there is no time \(t\) such that we have two measurements at that
time, \((x_1, t)\) and \((x_2, t)\), with \(x_1 \not= x_2\). At first
I believe this makes sense, you can't be in two different places at
the same time, but depending on the resolution we have for the time
this might happen, for example this is the case for the CDR data.
Another thing is that defining \(r\) as a subset of \(L \times
\mathbb{R}\) does not allow for duplicate measurements, i.e. two
measurements at the same time with the same location, I don't believe
this is a problem, we can simply remove any duplicates from the data
set. One benefit of having trajectories as sets is that it is easy to
talk about the union and intersection of several trajectories. One
drawback of not allowing multiple measurements at the same time would
be that the union of two trajectories might not be a trajectory. One
important thing to note is that we do not have any information about
an individual with this definition, trajectories are fully anonymous,
instead we encode the data about individuals in the co-trajectory.

With a co-trajectory we mean a number of trajectories that each
correspond to some, possible anonymized, individual. Let \(I\) be the
set of individuals, we can define a co-trajectory, \(R\) by a function
from \(I\) to \(T\). That is, a co-trajectory is given by a function
\(R: I \to T\) and the trajectory of an individual \(\iota \in I\) is
then given by the trajectory \(R(\iota) \in T\).

*Remarks:* One benefit of defining a co-trajectory as a function is
 that we get a natural way of talking about the trajectories of
 individuals. It also becomes easy to talk about sets of trajectories,
 for example \(R(I)\) is the set of trajectories for all the
 individuals. With \(R\) being a function we need to give trajectories
 for all individuals in \(I\), but if there is any individual we don't
 have any data for we can just give it the empty trajectory,
 \(R(\iota) = {\emptyset}\).
* Define a swap
We first define what we mean with a swap of two trajectories and then
what we mean with a =valid= swap.

Let \(r_1\) and \(r_2\) be two trajectories. Swapping \(r_1\) and
\(r_2\) at times \(t_1\) and \(t_2\) gives two new trajectories,
\(\overline{r_1}\) and \(\overline{r_2}\) given by
\begin{equation}
  \overline{r_1} = \{(x, t) \in r_1: t < t_1\} \cup \{(x, t) \in r_2: t \geq t_2\}
\end{equation}
and
\begin{equation}
  \overline{r_2} = \{(x, t) \in r_2: t < t_2\} \cup \{(x, t) \in r_1: t \geq t_1\}.
\end{equation}
Formally we can see it as a function \(\textrm{swap}: T \times T
\times \matbb{R} \times \mathbb{R} \to T \times T\) with
\begin{equation}
  \textrm{swap}(r_1, r_2, t_1, t_2) = (\overline{r_1}, \overline{r_2}).
\end{equation}

*Remarks:* We here have no requirements on which trajectories can be
swapped and at what times. It is basically just taking two
trajectories and swapping parts of their path. Note that the times
\(t_1\) and \(t_2\) doesn't even have to occur in the two
trajectories.

To define which swaps are =valid= we first define what we mean with
two measurements being =similar=. Two measurements \((x_1, t_1)\) and
\((x_2, t_2)\), are similar if \(d(x_1, x_2) < \chi\) and \(|t_1 -
t_2| < \tau\), we denote this by \((x_1, t_1) \approx (x_2, t_2)\).
From this we can say that two trajectories meet if they have
measurements which are similar. More precisely \(r_1\) and \(r_2\)
meet at time \((t_1, t_2)\) if there exists \((x_1, t_1) \in r_1\) and
\((x_2, t_2) \in r_2\) such that \((x_1, t_1) \approx (x_2, t_2)\), we
denote this by \(r_1 \approx_{(t_1, t_2)} r_2\).

*Remarks:* The notion of two measurements being similar depends on
\(\chi\) and \(\tau\) and they need to be chosen with respect to the
accuracy of the data. Two trajectories can meet several times and one
measurement can be involved in several meetings.

A swap of \(r_1\) and \(r_2\) at time \((t_1, t_2)\) is =valid= if
\(r_1 \approx_{(t_1, t_2)} r_2\).

*Remarks:* With this definition a swap can only be valid if the exact
times for the swap occur in the measurements, for a general swap this
was not required.
* Swaps on co-trajectories
A swap on a co-trajectory \(R\) is given by a pair of ids, the
trajectories to swap, and a pair of times, \((t_1, t_2)\), with the
times for the swap. Formally a swap is thus defined by an element from
the set \(I \times I \times \mathbb{R} \times \mathbb{R}\). The notion
of a =valid= swap is the same as before, the swap \((\iota_1, \iota_2,
t_1, t_2)\) is valid if \(R(\iota_1) \approx_{(t_1, t_2)}
R(\iota_2)\). We can also add the requirement that the ids should be
different. We can see it as a function \(\textrm{swap}: (I \to L
\times \mathbb{R}) \times I \times I \times \mathbb{R} \times
\mathbb{R} \to (I \to L \times \mathbb{R})\).

*Remarks:* The main problem with this definition is that the swap
given by \((\iota_1, \iota_2, t_1, t_2)\) is different from the swap
given by \((\iota_2, \iota_1, t_2, t_1)\) even though we would like
them to be the same. One way to solve this is to consider the
equivalence relation where two swaps are equivalent if and only if
they are on this form.

We can talk about the set of all swaps for a co-trajectory, with this
we mean the set \((I \times I \times \mathbb{R} \times
\mathbb{R})/\sim\) where \(\sim\) is the equivalence relation from the
above remark. A subset of the set of all swaps is the set of all
=valid= swaps, which we, for a co-trajectory \(R\), will denote by
\(S(R))\).

*Remarks:* With this all elements of \(S(R))\) are valid swaps and it
 does not contain duplicate swaps nor does it contain swaps of a
 trajectory with itself (because the latter are not valid swaps).

Given \(S(R)\) we want to perform some or all of these swaps on \(R\).
The problem here is that \(S(R)\) is not stable under swaps. Let \(s
\in S(R)\) be a swap and \(R' = \textrm{swap(R, s)}\) denote the
co-trajectory after performing the swap. In general we do not have
\(S(R) = S(R')\). Two things can happen, the ids of the possible swaps
can change or swaps that were not valid become valid or the other way
around.
** Example when ids swap
Consider the co-trajectory \(R\) given by \(I = \{\iota_1, \iota_2,
\iota_3}\) and
\begin{align}
  R(\iota_1) &= \{((0, 1), 0), ((1, 1), 1), ((2, 1), 2)\}\\
  R(\iota_2) &= \{((0, 2), 1), ((1, 2), 2), ((2, 2), 3)\}\\
  R(\iota_3) &= \{((1.05, 0), 0), ((1.05, 1), 1), ((1.05, 2), 2), ((1.05, 3), 3)\}\\
\end{align}
It has \(S(R) = \{(\iota_1, \iota_3, 1, 1), (\iota_2, \iota_3, 2,
2)\}\).

After performing the swap given by \((\iota_1, \iota_3, 1, 1)\) we get
the co-trajectory \(R'\) and now have \(S(R') = \{(\iota_1, \iota_3,
1, 1), (\iota_2, \iota_1, 2, 2)\}\). In particular \(S(R) \not=
S(R')\). See Figure [[fig:swap-ids]].

Essentially it is the same measurements which participate in the swaps
for \(S(R)\) and \(S(R')\) but they belong to different ids.
#+CAPTION: The co-trajectories \(R\) and \(R'\). The ids in \(S(R)\) and \(S(R')\) are different.
#+NAME:   fig:swap-ids
[[./figures/swap-ids.pdf]]
** Example when which swaps are valid change.
Consider the co-trajectory \(R\) given by \(I = \{\iota_1, \iota_2\}\)
and
\begin{align}
  R(\iota_1) &= \{((1.1, 0), 0), ((1.1, 1), 1), ((1, 1), 1.05), ((0, 1), 2)\}\\
  R(\iota_2) &= \{((1.05, 2), 0), ((1.1, 1.1), 1), ((2, 1.1), 2)\}\\
\end{align}
It has \(S(R) = \{(\iota_1, \iota_2, 1, 1), (\iota_1, \iota_2, 1.05,
1)\}\).

After performing the swap given by \((\iota_1, \iota_2, 1, 1)\) we get
the co-trajectory \(R'\) and now have \(S(R') = \{(\iota_1, \iota_2,
1, 1), (\iota_1, \iota_2, 1, 1.05)\}\). In particular \(S(R) \not=
S(R')\). See figure [[fig:swap-valid]].

Here the measurements that participates in the swaps has changed. In
the beginning the two measurements \(((1.1, 1), 1)\) and \(((1, 1),
1.05)\) were in the same trajectory and could not be used for a swap.
But after the first swap they are no longer in the same trajectory and
can now be used for a swap. Similarly, for the two measurements \(((1,
1), 1.05)\) and \(((1.1, 1.1), 1)\) could swap in the beginning but
after the first swap they are in the same trajectory and can't swap
anymore.
#+CAPTION: The co-trajectories \(R\) and \(R'\). The measurments that are valid for swaps are different for \(R\) and \(R'\).
#+NAME:   fig:swap-valid
[[./figures/swap-valid.pdf]]
** Handling multiple swaps
As seen the set of valid swaps for a co-trajectory can change when we
apply swaps to it. This means that we have no natural definition of
=applying all possible swaps= to a co-trajectory. For example one
natural thing to do would be to take the set of all valid swaps and
choose an order of them, we them perform the swaps in the given order.
The problem with this would then be that after performing the first
swap the second one might no longer be valid and there could also be
other swaps that become valid as we perform swaps.

How can we solve this? The type of problem occurring in example 1
above can be solved in a fairly natural way by, every time we perform
a swap also swap the ids of the relevant swaps in the list of swaps we
want to perform. Let \(S\) be the set of swaps we want to perform,
pick one \(s = (\iota_1, \iota_2, t_1, t_2) \in S\) and perform that
swap on the co-trajectory. After this the swaps in \(S\) might no
longer be valid swaps for the new co-trajectory, we can fix this by
replacing all swaps on the form \((\iota_1, \iota, t'_1, t),\ t'_1
\geq t_1\) in \(S\) with \((\iota_2, \iota, t'_1, t)\) and similar for
swaps on the form
\begin{align}
  (\iota, \iota_1, t, t'_1), & \ t'_1 \geq t_1,\\
  (\iota_2, \iota, t'_2, t), & \ t'_2 \geq t_2,\\
  (\iota, \iota_2, t, t'_2), & \ t'_2 \geq t_2.
\end{align}
What we are using here is essentially that the measurements which are
valid to use for swaps remain the same, the only difference being that
they might have swapped ids.

The type of problem occurring in the second example is harder to
handle. It would require us to remove and insert swaps in the list of
swaps we want to perform after every swap. Then we get a problem of
knowing which swaps have already been performed. In the previous case
we had a number of swaps in the beginning and then we only needed to
update some ids to keep them valid, it is fairly easy to keep track of
which swaps have been performed. I'm still not sure how to handle
this. The problem comes from the fact that we do not allow
trajectories to swap with themselves. If we allow trajectories to swap
with themselves this problem goes away, then the size of \(S(R)\) will
stay constant under swaps and only the ids will change. I believe this
would be the most natural solution to the problem but I'll have to
think more about the consequences.
** Order of swaps
The order of the swaps matter. For example consider the co-trajectory
\(R\) given by \(I = \{\iota_1, \iota_2, \iota_3\}\) and
\begin{align}
  R(\iota_1) &= \{((0, 0), 0), ((1, 0.95), 1), ((2, 0), 2)\}\\
  R(\iota_2) &= \{((0, 1), 0), ((1, 1.00), 1), ((2, 1), 2)\}\\
  R(\iota_3) &= \{((0, 2), 0), ((1, 1.05), 2), ((2, 2), 2)\}\\
\end{align}
It has \(S(R) = \{s_1, s_2, s_3\} = \{(\iota_1, \iota_2, 1, 1),
(\iota_1, \iota_3, 1, 1), (\iota_2, \iota_3, 1, 1)\}\).

There are six different orders to perform the swaps in, we'll show
that at least two of them are different. First consider the order
\(s_1 \to s_2 \to s_3\), it gives the result seen in Figure
[[fig:swap-order-1]]. Performing the swaps in the order \(s_2 \to s_1 \to
s_3\) gives us the result in Figure [[fig:swap-order-2]]. We can see that
the results are not the same.
#+CAPTION: Changes of the co-trajectory \(R\) when performing the swaps in the order \(s_1 \to s_2 \to s_3\).
#+NAME:   fig:swap-order-1
[[file:figures/swap-order-1.pdf]]

#+CAPTION: Changes of the co-trajectory \(R\) when performing the swaps in the order \(s_2 \to s_1 \to s_3\).
#+NAME:   fig:swap-order-2
[[file:figures/swap-order-2.pdf]]

Since the order of the swap matters we need to choose on to use, the
most natural thing is probably to take a random order.
* Give a complete algorithm
Following the discussions above a possible implementation would be to
first compute all possible swaps, including individuals swapping with
themselves. We then randomly choose and order to perform the swaps in.
When performing a swap we first check if it is a swap with itself, if
so we do nothing, otherwise randomly choose if we should apply the
swap or not. If we applied the swap we update the ids of all coming
swaps that they are still valid. We finish when we have gone through
all the swaps.

A Python implementation of the algorithm is given below.
#+INCLUDE: "SwapMob.py" src python

*Remarks:* The reason not to allow an individual to swap with itself
 is that it is not well defined what the new trajectory will be, we
 can give in two identical trajectories to the swap function but it
 will give out two different ones and we would have to choose one to
 use. The reason that will still allow swaps where individual swap
 with themselves is that when we get to that swap it might no longer
 be a swap with itself because we change the ids when updating swaps
 in every step. The implementation above is in no way optimized, I
 believe it has quadratic complexity which is probably not feasible
 for larger datasets.
* Privacy gains vs utility
What kind of privacy gains can we expect from =SwapMob=? I think it
depends a lot on what we assume about how trajectories of individuals
behave.

To begin with, what are we comparing with? We get the least amount of
privacy if we just publish the original co-trajectory with,
anonymized, individuals and their trajectories. On the other end I
would say that we have just publishing the measurements with no data
about individuals whatsoever. You could consider even more drastic
things, like not publishing any data at all, perturbing measurements
or removing/adding measurements/trajectories. I do however think that
it is somewhat natural to not touch the measurements and only the
individuals data and I'll therefore compare to publishing all data or
publishing only measurements.

Swapping trajectories can never give more privacy than only publishing
measurements. We therefore have to consider if publishing only
measurements preserves enough privacy for our use case, if that is not
the case swapping trajectories can never solve the problem. Assume
that we would be okay with publishing only measurements, the reason to
instead publish swapped trajectories would be that it keeps more of
the utility of the data but still might preserve enough privacy. What
we want to do is therefore to compare the amount of preserved privacy
between publishing all data and publishing swapped data and also
compare the utility from publishing only measurements to publishing
swapped data.

** Utility
I do not yet know enough to be able to compare utility for different
kinds of data. The reason is that I don't know what kind of analysis
you in general want to do with the data. We can look at different
metrics of the data and see which ones are preserved when we swap
trajectories or which ones only depend on the measurements and not on
which individual they belong to. But to do this I would need to know
which kinds of metrics are interesting.

** Privacy
I'll here give a couple of thoughts and ideas without much detail and
with no attempts of proofs.

The idea of =SwapMob= is that if an adversary is able to identify an
individual with part of a trajectory it only learns the moment of the
individual up until the next possible swap for that trajectory. But to
what extent is this true? To answer this question we need to do some
assumptions about the distribution of trajectories.

Assume that trajectories are Markov processes, given a point on a
trajectory you only need the information about the location and time
of that measurement to know the probability distribution of the next
point on the trajectory. In other words the movement of an individual
only depends on the current position and time and not on prior
movement. In this case I believe =SwapMob= works as intended. If an
adversary has identified parts of a trajectory that belongs to an
individual it can follow the trajectory of the individual up until the
next time it crosses another trajectory. With the assumption that
trajectories are Markov processes the adversary will not be able to
figure out if a swap occurred or not, it can only guess with a 50/50
chance of being correct. *Prove this*

If trajectories are not Markov processes but instead the movement of
an individual depends on the historic movement, =SwapMob= will not
work as well. For example assume that if an individual has been moving
in a straight line for some time the probability of it continuing in a
straight line is high. Consider the case of two trajectories going in
opposite directions meeting. If we swap these we would get two
trajectories that go in a straight line and then both turn around
completely at the same time. This scenario would be much more unlikely
than the case of both just continuing in a straight line, so if the
adversary sees this happening it can guess that a swap occurred here
and be correct with a high probability. *Formalise this*
